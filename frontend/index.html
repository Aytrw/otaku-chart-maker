<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACGN生涯个人喜好表</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: #f0f0f0;
            font-family: system-ui, -apple-system, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .ctrl-box {
            margin-top: 16px;
            margin-bottom: 16px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .ctrl-btn {
            background-color: #ea4c89;
            color: #fff;
            border: none;
            padding: 10px 30px;
            font-size: 15px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(234, 76, 137, 0.25);
            transition: background-color 0.3s;
        }
        .ctrl-btn:hover { background-color: #f082ac; }

        .grid-wrapper {
            background: #ffffff;
            padding: 30px;
            border-radius: 4px;
            box-shadow: 0 2px 16px rgba(0,0,0,0.08);
        }

        .grid-title {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(6, 150px);
            gap: 0;
        }

        .grid-cell {
            width: 150px;
            height: 240px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            border-right: 2px solid #333;
            border-bottom: 2px solid #333;
            background: #fff;
            display: flex;
            flex-direction: column;
            transition: opacity 0.15s;
        }
        .grid-cell:hover { opacity: 0.85; }

        /* 首行首列边框 */
        .grid-cell:nth-child(6n+1) { border-left: 2px solid #333; }
        .grid-cell:nth-child(-n+6) { border-top: 2px solid #333; }

        .cell-img-area {
            flex: 1;
            overflow: hidden;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fff;
        }
        .cell-img-area img {
            position: absolute;
            image-rendering: auto;
        }
        .cell-img-area .placeholder {
            color: #ccc;
            font-size: 28px;
            user-select: none;
        }

        .cell-label {
            height: 36px;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0f0f0;
            border-top: 1px solid #ccc;
            font-size: 13px;
            font-weight: bold;
            color: #333;
            white-space: nowrap;
            padding: 0 4px;
        }

        /* ========== 封面选择弹窗 ========== */
        .cover-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.55);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .cover-modal.active { display: flex; }

        .cover-modal-inner {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 18px 20px;
            max-width: 960px;
            max-height: 92vh;
            overflow: hidden;
            width: 94%;
            box-shadow: 0 8px 30px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
        }
        .cover-modal-title {
            font-size: 15px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
            text-align: center;
            flex-shrink: 0;
        }
        .cover-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
            padding: 4px 6px;
        }
        .cover-item {
            position: relative;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid #ddd;
            aspect-ratio: 3/4;
            border-radius: 4px;
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.2s;
        }
        .cover-item:hover {
            border-color: #ea4c89;
            box-shadow: 0 0 10px rgba(234,76,137,0.35);
            transform: scale(1.03);
            z-index: 1;
        }
        .cover-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            image-rendering: auto;
        }
        .cover-modal-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 14px;
            flex-shrink: 0;
        }
        .cover-modal-btn {
            padding: 7px 24px;
            border: none;
            border-radius: 5px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
        }
        .cover-modal-btn.close-btn { background: #eee; color: #555; }
        .cover-modal-btn.close-btn:hover { background: #ddd; }
        .cover-modal-btn.clear-btn { background: #ff6b6b; color: #fff; }
        .cover-modal-btn.clear-btn:hover { background: #ee5a5a; }

        .no-covers-msg {
            text-align: center;
            color: #999;
            padding: 36px 20px;
            font-size: 13px;
            line-height: 2;
            grid-column: 1 / -1;
        }

        /* 封面工具栏 */
        .cover-toolbar {
            display: flex;
            justify-content: flex-end;
            gap: 6px;
            margin-bottom: 8px;
        }
        .cover-tool-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 12px;
            border: 1.5px solid #ddd;
            border-radius: 6px;
            background: #fff;
            font-size: 11px;
            font-weight: bold;
            color: #555;
            cursor: pointer;
            transition: all 0.15s;
        }
        .cover-tool-btn:hover { border-color: #ea4c89; color: #ea4c89; }
        .cover-tool-btn:active { background: #fce4ec; }
        .cover-tool-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Tab 切换 */
        .modal-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 10px;
            border-bottom: 2px solid #eee;
            flex-shrink: 0;
        }
        .modal-tab {
            flex: 1;
            padding: 10px 0;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            background: none;
            border-top: none; border-left: none; border-right: none;
        }
        .modal-tab:hover { color: #666; }
        .modal-tab.active {
            color: #ea4c89;
            border-bottom-color: #ea4c89;
        }
        .tab-panel { display: none; }
        .tab-panel.active {
            display: block;
            flex: 1 1 auto;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            padding-right: 6px;
        }
        .tab-panel.active::-webkit-scrollbar { width: 6px; }
        .tab-panel.active::-webkit-scrollbar-track { background: transparent; }
        .tab-panel.active::-webkit-scrollbar-thumb { background: #ddd; border-radius: 3px; }
        .tab-panel.active::-webkit-scrollbar-thumb:hover { background: #ccc; }

        /* 搜索面板（占位，后续迁移） */
        .search-bar {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .search-bar input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }
        .search-bar input:focus { border-color: #ea4c89; }
        .search-bar select {
            padding: 8px 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
            background: #fff;
            cursor: pointer;
            outline: none;
        }
        .search-bar select:focus { border-color: #ea4c89; }
        .search-bar button {
            padding: 8px 18px;
            background: #ea4c89;
            color: #fff;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            white-space: nowrap;
        }
        .search-bar button:hover { background: #f082ac; }
        .search-bar button:disabled { background: #ccc; cursor: not-allowed; }

        .search-results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 6px;
        }
        .search-item {
            cursor: pointer;
            border: 2px solid #eee;
            border-radius: 6px;
            overflow: hidden;
            transition: border-color 0.15s, box-shadow 0.15s;
            background: #fff;
        }
        .search-item:hover {
            border-color: #ea4c89;
            box-shadow: 0 2px 10px rgba(234,76,137,0.2);
        }
        .search-item-img {
            width: 100%;
            aspect-ratio: 3/4;
            object-fit: cover;
            display: block;
            background: #f5f5f5;
        }
        .search-item-info {
            padding: 2px 4px 1px;
        }
        .search-item-name {
            font-size: 10px;
            font-weight: bold;
            color: #333;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 1;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .search-item-sub {
            font-size: 9px;
            color: #999;
            margin-top: 1px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: none;
        }
        .search-status {
            text-align: center;
            padding: 36px 20px;
            color: #aaa;
            font-size: 13px;
            line-height: 1.8;
        }
        .search-status-icon {
            font-size: 32px;
            display: block;
            margin-bottom: 8px;
            opacity: 0.5;
        }
        .search-status .spinner {
            display: inline-block;
            width: 20px; height: 20px;
            border: 3px solid #eee;
            border-top-color: #ea4c89;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            margin-bottom: 8px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* 下载中覆盖层 */
        .download-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.4);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .download-overlay-box {
            background: #fff;
            padding: 24px 36px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        .download-overlay-box .spinner {
            width: 28px; height: 28px;
            border: 3px solid #eee;
            border-top-color: #ea4c89;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            margin: 0 auto 10px;
        }

        /* 标签浏览 */
        .tag-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 10px;
        }
        .tag-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 12px;
            background: #fce4ec;
            color: #c62828;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        .tag-badge .remove-tag {
            cursor: pointer;
            font-size: 14px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .tag-badge .remove-tag:hover { opacity: 1; }
        .result-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            color: #999;
        }
        .search-item-meta {
            display: flex;
            align-items: center;
            gap: 3px;
            padding: 1px 4px 3px;
        }
        .search-item-type {
            font-size: 10px;
            padding: 1px 6px;
            border-radius: 3px;
            font-weight: bold;
            background: #e3f2fd;
            color: #1565c0;
        }
        .search-item-type.type-anime { background: #e3f2fd; color: #1565c0; }
        .search-item-type.type-game  { background: #fce4ec; color: #c62828; }
        .search-item-type.type-manga { background: #fff3e0; color: #e65100; }
        .search-item-type.type-novel { background: #f3e5f5; color: #7b1fa2; }
        .search-item-score {
            font-size: 10px;
            color: #ff9800;
            font-weight: bold;
        }
        /* 来源徽章 */
        .source-badge {
            font-size: 10px;
            padding: 1px 6px;
            border-radius: 3px;
            font-weight: bold;
        }
        .source-badge.source-bgm  { background: #e8f0fe; color: #3b6ece; }
        .source-badge.source-vndb { background: #f3e5f5; color: #7b1fa2; }
        .load-more-wrapper {
            text-align: center;
            padding: 16px 0;
            grid-column: 1 / -1;
        }
        .load-more-btn {
            padding: 8px 32px;
            background: #fff;
            border: 2px solid #ea4c89;
            color: #ea4c89;
            border-radius: 20px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        .load-more-btn:hover {
            background: #ea4c89;
            color: #fff;
        }
        .load-more-btn:disabled { background: #eee; border-color: #ccc; color: #999; cursor: not-allowed; }

        /* 类型筛选 */
        .type-filter-row {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        .type-btn {
            padding: 4px 14px;
            border: 1.5px solid #ddd;
            border-radius: 14px;
            background: #fff;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            color: #555;
            transition: all 0.15s;
        }
        .type-btn:hover { border-color: #ea4c89; color: #ea4c89; }
        .type-btn.active {
            background: #ea4c89;
            border-color: #ea4c89;
            color: #fff;
        }

        /* 数据源选择 */
        .source-selector-row {
            display: flex;
            gap: 10px;
            margin-bottom: 14px;
            padding-bottom: 14px;
            border-bottom: 1px solid #f0f0f0;
        }
        .source-btn-wrap {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }
        .source-btn {
            padding: 7px 22px;
            border: 2px solid #ddd;
            border-radius: 18px;
            background: #fff;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            color: #555;
            transition: all 0.2s;
        }
        .source-btn:hover { border-color: #ea4c89; color: #ea4c89; background: #fff5f8; }
        .source-btn.active {
            background: #ea4c89;
            border-color: #ea4c89;
            color: #fff;
            box-shadow: 0 2px 8px rgba(234,76,137,0.25);
        }
        .source-desc {
            font-size: 10px;
            color: #b0b0b0;
            white-space: nowrap;
            transition: color 0.15s;
        }
        .source-btn-wrap:has(.source-btn.active) .source-desc {
            color: #e06090;
        }

        /* 面板区块标题 */
        .section-label {
            font-size: 12px;
            color: #888;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .section-label::before {
            content: '';
            width: 3px;
            height: 13px;
            background: #ea4c89;
            border-radius: 2px;
            flex-shrink: 0;
        }
        .section-label .section-hint {
            font-weight: 400;
            color: #bbb;
            margin-left: 2px;
        }

        /* VNDB 引导提示 */
        .vndb-guide {
            background: linear-gradient(135deg, #f8f0ff 0%, #f0f4ff 100%);
            border: 1px solid #e8dff5;
            border-radius: 8px;
            padding: 12px 14px;
            margin-bottom: 12px;
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }
        .vndb-guide-icon {
            font-size: 18px;
            flex-shrink: 0;
            line-height: 1.4;
        }
        .vndb-guide-text {
            font-size: 12px;
            color: #666;
            line-height: 1.7;
        }
        .vndb-guide-text strong {
            color: #7b1fa2;
        }

        /* 分页 */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 4px;
            padding: 12px 0 4px;
            flex-wrap: wrap;
            grid-column: 1 / -1;
        }
        .page-btn {
            min-width: 32px;
            height: 32px;
            padding: 0 8px;
            border: 1.5px solid #ddd;
            border-radius: 6px;
            background: #fff;
            font-size: 13px;
            cursor: pointer;
            color: #555;
            transition: all 0.15s;
        }
        .page-btn:hover { border-color: #ea4c89; color: #ea4c89; }
        .page-btn.active { background: #ea4c89; border-color: #ea4c89; color: #fff; font-weight: bold; }
        .page-btn:disabled { background: #f5f5f5; color: #ccc; cursor: not-allowed; border-color: #eee; }
        .page-ellipsis { color: #aaa; font-size: 13px; padding: 0 4px; }

        /* 标签浏览器 */
        .tag-browser {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 8px 10px;
            background: #fafafa;
            margin-bottom: 8px;
        }
        .tag-cat-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 5px;
        }
        .tag-cat-row:last-child { margin-bottom: 0; }
        .tag-cat-label {
            font-size: 11px;
            color: #999;
            white-space: nowrap;
            min-width: 32px;
            font-weight: bold;
        }
        .tag-cat-group {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        .tag-pick-btn {
            padding: 2px 8px;
            border: 1.5px solid #ddd;
            border-radius: 12px;
            background: #fff;
            font-size: 12px;
            cursor: pointer;
            color: #555;
            transition: all 0.15s;
            line-height: 1.5;
        }
        .tag-pick-btn:hover { border-color: #ea4c89; color: #ea4c89; }
        .tag-pick-btn.active {
            background: #ea4c89;
            border-color: #ea4c89;
            color: #fff;
        }
        .search-sort-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
        }
        .search-sort-row label {
            font-size: 12px;
            color: #999;
            white-space: nowrap;
        }
        .sort-select {
            flex: 1;
            padding: 6px 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
            background: #fff;
            cursor: pointer;
            outline: none;
        }
        .sort-select:focus { border-color: #ea4c89; }

        /* 封面编辑按钮 */
        .cover-edit-btn {
            position: absolute;
            top: 4px; right: 4px;
            width: 26px; height: 26px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
        }
        .cover-item:hover .cover-edit-btn { opacity: 1; }
        .grid-cell:hover .cover-edit-btn { opacity: 1; }
        .cover-edit-btn:hover { background: #ea4c89 !important; }

        /* 裁剪编辑器 */
        .crop-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.78);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }
        .crop-modal.active { display: flex; }
        .crop-modal-inner {
            background: #fff;
            border-radius: 12px;
            padding: 20px;
            width: min(700px, 95vw);
            max-height: 94vh;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 8px 40px rgba(0,0,0,0.45);
        }
        .crop-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .crop-title {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 80%;
        }
        .crop-close-x {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #aaa;
            padding: 0 2px;
            line-height: 1;
        }
        .crop-close-x:hover { color: #333; }
        .crop-body {
            display: flex;
            gap: 14px;
            align-items: stretch;
        }
        .crop-workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .crop-stage {
            background: #1c1c1c;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }
        .crop-viewport {
            width: min(360px, 65vw);
            aspect-ratio: 3 / 4;
            max-height: 56vh;
            overflow: hidden;
            position: relative;
            border-radius: 6px;
            border: 2px solid rgba(255,255,255,0.18);
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.1);
            cursor: move;
            background: #000;
            touch-action: none;
            transition: border-color 0.15s;
        }
        .crop-viewport:hover {
            border-color: rgba(234,76,137,0.4);
        }
        .crop-viewport.dragging {
            cursor: move;
            border-color: rgba(234,76,137,0.7);
        }
        .crop-img {
            position: absolute;
            user-select: none;
            pointer-events: none;
        }
        .crop-grid-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
            background-image:
                linear-gradient(to right, rgba(255,255,255,0.6) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255,255,255,0.6) 1px, transparent 1px);
            background-size: 33.333% 33.333%;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.4);
        }
        .crop-center-mark {
            position: absolute;
            top: 50%; left: 50%;
            width: 20px; height: 20px;
            margin: -10px 0 0 -10px;
            pointer-events: none;
            z-index: 2;
            opacity: 0.6;
            transition: opacity 0.15s;
        }
        .crop-center-mark::before,
        .crop-center-mark::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.9);
            box-shadow: 0 0 3px rgba(0,0,0,0.7);
            border-radius: 1px;
        }
        .crop-center-mark::before {
            left: 0; right: 0; top: 50%;
            height: 2px; margin-top: -1px;
        }
        .crop-center-mark::after {
            top: 0; bottom: 0; left: 50%;
            width: 2px; margin-left: -1px;
        }
        .crop-viewport:hover .crop-center-mark,
        .crop-viewport.dragging .crop-center-mark { opacity: 1; }
        .crop-controls {
            background: #f7f7f7;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .crop-control {
            display: grid;
            grid-template-columns: 66px 1fr 42px;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #666;
        }
        .crop-control input[type="range"] {
            width: 100%;
            accent-color: #ea4c89;
        }
        .crop-control-value {
            text-align: right;
            font-variant-numeric: tabular-nums;
            color: #333;
            font-weight: bold;
        }
        .crop-side {
            width: 180px;
            min-width: 180px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .crop-preview-card {
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px;
        }
        .crop-preview-title {
            font-size: 12px;
            color: #777;
            margin-bottom: 8px;
            font-weight: bold;
        }
        .crop-preview-box {
            width: 126px;
            aspect-ratio: 3 / 4;
            border: 1.5px solid #ddd;
            border-radius: 6px;
            overflow: hidden;
            margin: 0 auto;
            position: relative;
            background: #111;
        }
        .crop-preview-tip {
            font-size: 11px;
            color: #999;
            margin-top: 8px;
            line-height: 1.5;
        }
        .crop-hint {
            font-size: 11px;
            color: #888;
            line-height: 1.6;
        }
        .crop-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .crop-reset-btn {
            padding: 7px 18px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fff;
            cursor: pointer;
            font-size: 13px;
            color: #666;
        }
        .crop-reset-btn:hover { border-color: #bbb; background: #f8f8f8; }
        .crop-cancel-btn {
            padding: 7px 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f5f5f5;
            cursor: pointer;
            font-size: 13px;
        }
        .crop-save-btn {
            padding: 7px 22px;
            border: none;
            border-radius: 5px;
            background: #ea4c89;
            color: #fff;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
        }
        .crop-save-btn:hover { background: #d93a77; }
        .crop-save-btn:disabled { background: #ccc; cursor: not-allowed; }

        #exportCanvas { display: none; }
    </style>
</head>
<body>

    <div class="grid-wrapper">
        <div class="grid-title">ACGN生涯个人喜好表</div>
        <div class="grid-container" id="gridContainer"></div>
    </div>

    <div class="ctrl-box">
        <button class="ctrl-btn" onclick="saveImage()">💾 保存为图片</button>
    </div>

    <!-- 封面选择弹窗 -->
    <div class="cover-modal" id="coverModal">
        <div class="cover-modal-inner">
            <div class="cover-modal-title" id="modalTitle">选择封面</div>

            <div class="modal-tabs">
                <button class="modal-tab active" data-tab="covers" onclick="switchTab('covers')">📁 已有封面</button>
                <button class="modal-tab" data-tab="search" onclick="switchTab('search')">🔍 搜索作品</button>
            </div>

            <!-- 已有封面 -->
            <div class="tab-panel active" id="tabCovers">
                <div class="cover-toolbar">
                    <button class="cover-tool-btn" onclick="triggerUploadCover()" title="从本地导入图片到 covers 目录">📂 导入封面</button>
                    <button class="cover-tool-btn" onclick="refreshCovers()" title="刷新 covers 目录（拖入新文件后点击）">🔄 刷新</button>
                </div>
                <input type="file" id="uploadCoverInput" accept="image/*" multiple style="display:none" onchange="handleUploadFiles(this.files)">
                <div class="cover-grid" id="coverGrid"></div>
            </div>

            <!-- 搜索作品 -->
            <div class="tab-panel" id="tabSearch">
                <!-- 数据源选择 -->
                <div class="section-label">选择数据来源</div>
                <div class="source-selector-row">
                    <div class="source-btn-wrap">
                        <button class="source-btn active" data-source="bgm" onclick="setSource('bgm')"
                            title="Bangumi 番组计划 — 综合性 ACGN 信息站，收录动画、漫画、游戏、音乐、小说等条目，拥有丰富的标签和评分体系">📺 Bangumi</button>
                        <span class="source-desc">动画 / 漫画 / 游戏 / 小说</span>
                    </div>
                    <div class="source-btn-wrap">
                        <button class="source-btn" data-source="vndb" onclick="setSource('vndb')"
                            title="VNDB (The Visual Novel Database) — 全球最大的视觉小说数据库，专注收录 Galgame 与视觉小说作品，支持中日英名称搜索">🎮 VNDB</button>
                        <span class="source-desc">Galgame / 视觉小说</span>
                    </div>
                </div>

                <!-- Bangumi 专属控件（VNDB 模式下隐藏） -->
                <div id="bgmControls">
                    <div class="section-label">题材标签 <span class="section-hint">— 点击添加标签组合筛选，可多选</span></div>
                    <div class="tag-browser" id="tagBrowser"></div>
                    <div class="tag-badges" id="tagBadges"></div>
                    <div class="section-label">类型筛选</div>
                    <div class="type-filter-row" id="typeFilterRow">
                        <button class="type-btn active" data-type="all" onclick="setSubjectType('all')">📦 全部</button>
                        <button class="type-btn" data-type="anime" onclick="setSubjectType('anime')">🎥 动画</button>
                        <button class="type-btn" data-type="manga" onclick="setSubjectType('manga')">📖 漫画</button>
                        <button class="type-btn" data-type="novel" onclick="setSubjectType('novel')">📝 小说</button>
                        <button class="type-btn" data-type="game" onclick="setSubjectType('game')">🎮 游戏</button>
                    </div>
                    <div class="section-label">排序方式</div>
                    <div class="search-sort-row">
                        <select class="sort-select" id="sortSelect" onchange="onSortChange()">
                            <option value="rank">按排名</option>
                            <option value="score">按评分</option>
                            <option value="heat" selected>按热度</option>
                            <option value="match">按匹配度（需关键词）</option>
                        </select>
                    </div>
                </div><!-- /bgmControls -->

                <!-- VNDB 引导提示（BGM 模式下隐藏） -->
                <div id="vndbGuide" class="vndb-guide" style="display:none">
                    <div class="vndb-guide-icon">💡</div>
                    <div class="vndb-guide-text">
                        <strong>VNDB 搜索提示</strong>：直接输入视觉小说的中文名、日文原名或英文名进行搜索。
                        支持模糊匹配，结果按相关度排序。点击作品卡片即可下载封面并应用到格子中。
                    </div>
                </div>

                <!-- 关键词搜索 -->
                <div class="section-label" id="searchBarLabel">关键词 <span class="section-hint">— 输入作品名称进一步筛选</span></div>
                <div class="search-bar">
                    <input type="text" id="searchInput" placeholder="输入关键词进一步筛选（可选）..." onkeydown="if(event.key==='Enter') doSearch()">
                    <button onclick="doSearch()" id="searchBtn">搜索</button>
                </div>
                <!-- 结果信息 -->
                <div id="resultInfo" class="result-info" style="display:none;"><span id="resultCount"></span></div>
                <!-- 搜索结果 -->
                <div id="searchResults">
                    <div class="search-status"><span class="search-status-icon">🔍</span>选择上方题材标签，或直接输入关键词搜索</div>
                </div>
                <!-- 分页 -->
                <div id="pagination" class="pagination"></div>
            </div>

            <div class="cover-modal-actions">
                <button class="cover-modal-btn clear-btn" onclick="clearCover()">清除封面</button>
                <button class="cover-modal-btn close-btn" onclick="closeModal()">关闭</button>
            </div>
        </div>
    </div>

    <!-- 裁剪弹窗 -->
    <div class="crop-modal" id="cropModal">
        <div class="crop-modal-inner">
            <div class="crop-header">
                <div class="crop-title" id="cropTitle">裁剪封面</div>
                <button class="crop-close-x" onclick="closeCropModal()" aria-label="关闭">×</button>
            </div>
            <div class="crop-body">
                <div class="crop-workspace">
                    <div class="crop-stage">
                        <div class="crop-viewport" id="cropViewport">
                            <img id="cropImage" class="crop-img" alt="crop-source" draggable="false">
                            <div class="crop-grid-overlay"></div>
                            <div class="crop-center-mark"></div>
                        </div>
                    </div>
                    <div class="crop-controls">
                        <div class="crop-control">
                            <span>缩放</span>
                            <input id="cropZoom" type="range" min="100" max="300" step="1">
                            <span id="cropZoomValue" class="crop-control-value">100%</span>
                        </div>
                        <div class="crop-control">
                            <span>横向</span>
                            <input id="cropX" type="range" min="0" max="100" step="1">
                            <span id="cropXValue" class="crop-control-value">50%</span>
                        </div>
                        <div class="crop-control">
                            <span>纵向</span>
                            <input id="cropY" type="range" min="0" max="100" step="1">
                            <span id="cropYValue" class="crop-control-value">50%</span>
                        </div>
                    </div>
                    <div class="crop-hint">拖拽图片可快速调整裁剪区域；该操作只影响当前格子显示，不会修改 covers 原图。</div>
                </div>
                <div class="crop-side">
                    <div class="crop-preview-card">
                        <div class="crop-preview-title">裁剪预览</div>
                        <div class="crop-preview-box">
                            <img id="cropPreviewImage" class="crop-img" alt="crop-preview" draggable="false">
                        </div>
                        <div class="crop-preview-tip">预览与格子显示及导出保持一致。</div>
                    </div>
                </div>
            </div>
            <div class="crop-actions">
                <button class="crop-reset-btn" onclick="resetCropDraft()">重置</button>
                <button class="crop-cancel-btn" onclick="closeCropModal()">取消</button>
                <button class="crop-save-btn" onclick="saveCropDraft()">应用裁剪</button>
            </div>
        </div>
    </div>

    <canvas id="exportCanvas"></canvas>

<script>
    // texts 定义 6×10 网格的 60 个分类标签。
    const texts = [
        "入坑作", "最喜欢", "看最多次", "最想安利", "最一眼缘", "最震撼",
        "最治愈", "最搞笑", "最感动", "最热血", "最致郁", "最电波",
        "最佳剧情", "最佳演出", "最佳音乐", "最佳世界观", "最佳角色塑造", "扭的最厉害",
        "最佳恋爱", "最佳修罗场", "最佳后宫", "最佳百合", "最佳耽美", "最佳群像",
        "最佳日常", "最佳校园", "最佳运动", "最佳战斗", "最佳智斗", "最佳悬疑",
        "最佳奇幻", "最佳科幻", "最佳机甲", "最佳冒险", "最佳史诗", "最佳末日",
        "最佳异世界", "最佳穿越", "最佳架空", "最佳转生", "最佳原创", "最佳改编",
        "最佳时间轮回", "最佳叙诡", "最佳伪娘", "最佳超能力", "最佳职场", "最佳美食",
        "小众最爱", "最爱画风", "最爱长篇", "最恐怖", "最写实", "常听说从未看",
        "花最多钱", "最被低估", "最过誉", "最胃疼", "最期续作", "最讨厌"
    ];

    // cellImages 保存每个格子的封面 URL。
    const cellImages = new Array(texts.length).fill(null);
    // cellCrops 保存每个格子的裁剪参数（仅影响当前用户展示与导出，不改原图）。
    const cellCrops = new Array(texts.length).fill(null);
    // coverUrls 保存 /api/covers 返回的封面列表。
    let coverUrls = [];
    // activeCellIndex 记录当前正在编辑的格子索引。
    let activeCellIndex = -1;
    // _imgCache 缓存已加载图片，减少重复导出时的网络和解码开销。
    const _imgCache = new Map();
    // 裁剪编辑状态
    let cropEditingIndex = -1;
    let cropDraft = null;
    let cropDragging = false;
    let cropDragStartX = 0;
    let cropDragStartY = 0;

    // 搜索面板的题材标签分组，用于 Bangumi tag 浏览。
    const allTags = [
        { label: "情感", tags: ["治愈", "搞笑", "热血", "感动", "催泪", "致郁", "恐怖", "温馨", "燃", "虐心", "压抑", "紧张"] },
        { label: "恋爱", tags: ["恋爱", "青春", "百合", "BL", "后宫", "纯爱", "暗恋", "三角关系", "初恋", "姐弟恋"] },
        { label: "日常", tags: ["日常", "校园", "职场", "美食", "音乐", "偶像", "运动", "旅行", "料理", "家庭", "社团"] },
        { label: "战斗", tags: ["战斗", "冒险", "超能力", "竞技", "格斗", "军事", "机战", "武术", "生存", "魔法少女"] },
        { label: "推理", tags: ["推理", "悬疑", "智斗", "犯罪", "惊悚", "心理", "侦探", "复仇", "解谜"] },
        { label: "幻想", tags: ["奇幻", "科幻", "机甲", "赛博朋克", "魔法", "妖怪", "吸血鬼", "玄幻", "人外"] },
        { label: "背景", tags: ["异世界", "穿越", "转生", "架空", "末日", "史诗", "神话", "历史", "宫廷", "近未来", "废土", "太空"] },
        { label: "叙事", tags: ["剧情", "原创", "改编", "写实", "叙述性诡计", "时间循环", "群像剧", "意识流"] },
        { label: "角色", tags: ["群像", "伪娘", "兽耳", "傲娇", "病娇", "天然呆", "腹黑", "女仆", "大小姐", "萌系"] },
        { label: "受众", tags: ["少年", "少女", "青年", "乙女", "GL", "子供向", "猎奇", "女性向"] },
    ];

    // 搜索状态
    let currentTags = [];           // 当前选中的标签列表
    let currentPage = 1;            // 当前页码
    let currentTotal = 0;           // 搜索结果总数
    let currentSubjectType = "all"; // 类型筛选
    let _cachedPageSize = 0;        // 缓存的每页条数
    const SEARCH_ROWS = 2;           // 搜索结果显示行数
    const MIN_ITEM_WIDTH = 100;      // 搜索卡片最小宽度
    const SEARCH_GAP = 6;            // 搜索网格间距
    // getSearchPageSize 根据弹窗宽度动态计算每页条目数（固定 2 行，无空位）。
    function getSearchPageSize() {
        if (_cachedPageSize > 0) return _cachedPageSize;
        const modal = document.querySelector(".cover-modal-inner");
        // modal padding 20px×2, tab-panel padding-right 6px
        const availableWidth = modal && modal.clientWidth > 0
            ? (modal.clientWidth - 46) : 880;
        const cols = Math.max(1, Math.floor(
            (availableWidth + SEARCH_GAP) / (MIN_ITEM_WIDTH + SEARCH_GAP)
        ));
        _cachedPageSize = cols * SEARCH_ROWS;
        return _cachedPageSize;
    }
    function resetPageSizeCache() { _cachedPageSize = 0; }
    let _searchTimer = null;        // 搜索防抖计时器
    let _loadingRequests = 0;       // 正在进行的加载请求数量
    let _searchVersion = 0;         // 搜索版本号，用于隔离旧请求结果
    const _pageCache = new Map();   // 分页缓存 key -> data
    const _inflight = new Map();    // 请求去重 key -> Promise
    const CACHE_LIMIT = 120;        // 分页缓存上限，避免无限增长
    const PREFETCH_STEPS = [1, 2, -1]; // 预加载顺序：后1页、后2页、前1页

    // 数据源选择："bgm" 或 "vndb"
    let currentSource = "bgm";

    // VNDB 搜索状态（独立于 Bangumi）
    let vndbPage = 1;
    let vndbTotal = 0;
    let _vndbSearchTimer = null;
    let _vndbLoadingRequests = 0;
    let _vndbSearchVersion = 0;
    const _vndbPageCache = new Map();
    const _vndbInflight = new Map();
    const VNDB_PREFETCH_STEPS = [1]; // VNDB 仅预加载后 1 页

    // initGrid 创建 60 个网格格子并绑定点击事件。
    function initGrid() {
        const container = document.getElementById("gridContainer");
        container.innerHTML = "";
        texts.forEach((text, i) => {
            const cell = document.createElement("div");
            cell.className = "grid-cell";
            cell.onclick = () => openCoverPicker(i);
            cell.innerHTML = `
                <div class="cell-img-area" id="imgArea${i}">
                    <span class="placeholder">＋</span>
                </div>
                <div class="cell-label">${text}</div>
            `;
            container.appendChild(cell);
            renderCellImage(i, text);
        });
    }

    function defaultCrop() {
        return { zoom: 1, centerX: 0.5, centerY: 0.5 };
    }

    function cloneCrop(crop) {
        return {
            zoom: Number(crop?.zoom ?? 1),
            centerX: Number(crop?.centerX ?? 0.5),
            centerY: Number(crop?.centerY ?? 0.5),
        };
    }

    function clampCrop(crop) {
        crop.zoom = Math.min(3, Math.max(1, Number(crop.zoom) || 1));
        const cx = Number(crop.centerX);
        const cy = Number(crop.centerY);
        crop.centerX = Math.min(1, Math.max(0, isNaN(cx) ? 0.5 : cx));
        crop.centerY = Math.min(1, Math.max(0, isNaN(cy) ? 0.5 : cy));
        return crop;
    }

    function getCellCrop(index) {
        return clampCrop(cloneCrop(cellCrops[index] || defaultCrop()));
    }

    // computeCropLayout 根据图片原始尺寸、容器宽高比和裁剪参数计算定位百分比。
    function computeCropLayout(natW, natH, containerRatio, crop) {
        const imgRatio = natW / natH;
        let wPct, hPct;
        if (imgRatio > containerRatio) {
            hPct = 100 * crop.zoom;
            wPct = 100 * crop.zoom * imgRatio / containerRatio;
        } else {
            wPct = 100 * crop.zoom;
            hPct = 100 * crop.zoom * containerRatio / imgRatio;
        }
        const overflowX = wPct - 100;
        const overflowY = hPct - 100;
        return {
            width: wPct + '%',
            height: hPct + '%',
            left: -(crop.centerX * overflowX) + '%',
            top: -(crop.centerY * overflowY) + '%',
        };
    }

    // applyCropLayoutToElement 将裁剪布局应用到图片元素。
    function applyCropLayoutToElement(img, layout) {
        img.style.objectFit = '';
        img.style.objectPosition = '';
        img.style.width = layout.width;
        img.style.height = layout.height;
        img.style.left = layout.left;
        img.style.top = layout.top;
    }

    function renderCellImage(index, altText = "cover") {
        const area = document.getElementById(`imgArea${index}`);
        if (!area) return;
        area.innerHTML = "";

        const url = cellImages[index];
        if (!url) {
            const placeholder = document.createElement("span");
            placeholder.className = "placeholder";
            placeholder.textContent = "＋";
            area.appendChild(placeholder);
            return;
        }

        const crop = getCellCrop(index);
        const img = document.createElement("img");
        img.src = url;
        img.alt = altText;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        img.style.objectPosition = `${crop.centerX * 100}% ${crop.centerY * 100}%`;
        img.onload = () => {
            const r = (area.offsetWidth && area.offsetHeight)
                ? area.offsetWidth / area.offsetHeight : 150 / 204;
            const layout = computeCropLayout(img.naturalWidth, img.naturalHeight, r, crop);
            applyCropLayoutToElement(img, layout);
        };
        area.appendChild(img);

        const editBtn = document.createElement("button");
        editBtn.className = "cover-edit-btn";
        editBtn.type = "button";
        editBtn.title = "裁剪封面";
        editBtn.textContent = "✂";
        editBtn.onclick = (e) => {
            e.stopPropagation();
            openCropModal(index);
        };
        area.appendChild(editBtn);
    }

    // loadCovers 从后端加载 covers 目录中的封面列表。
    async function loadCovers() {
        try {
            const resp = await fetch("/api/covers");
            if (!resp.ok) return;
            const list = await resp.json();
            coverUrls = list.map(n => ({ name: n, url: "covers/" + encodeURIComponent(n) }));
        } catch (e) {
            console.warn("加载封面失败:", e);
        }
    }

    // refreshCovers 手动刷新封面列表并重新渲染弹窗内网格。
    async function refreshCovers() {
        await loadCovers();
        renderCoverGrid();
    }

    // renderCoverGrid 渲染弹窗内的已有封面网格。
    function renderCoverGrid() {
        const grid = document.getElementById("coverGrid");
        if (!grid) return;
        grid.innerHTML = "";
        if (coverUrls.length === 0) {
            grid.innerHTML = `<div class="no-covers-msg">covers 文件夹中没有找到图片<br>点击「导入封面」上传本地图片，或切换到 Bangumi / VNDB Tab 在线搜索</div>`;
            return;
        }
        coverUrls.forEach(({ name, url }) => {
            const item = document.createElement("div");
            item.className = "cover-item";
            item.innerHTML = `<img src="${url}" alt="${name}" title="${name}">`;
            item.onclick = (e) => { e.stopPropagation(); selectCover(url, name); };
            grid.appendChild(item);
        });
    }

    // triggerUploadCover 触发文件选择对话框。
    function triggerUploadCover() {
        document.getElementById("uploadCoverInput").click();
    }

    // handleUploadFiles 上传选中的图片文件到后端 covers 目录。
    async function handleUploadFiles(files) {
        if (!files || files.length === 0) return;
        const overlay = document.createElement("div");
        overlay.className = "download-overlay";
        overlay.innerHTML = `<div class="download-overlay-box">
            <div class="spinner"></div>
            <div>正在导入封面（0/${files.length}）...</div>
        </div>`;
        document.body.appendChild(overlay);
        const msgEl = overlay.querySelector("div > div:last-child");

        let lastFilename = null;
        try {
            for (let i = 0; i < files.length; i++) {
                msgEl.textContent = `正在导入封面（${i + 1}/${files.length}）...`;
                const form = new FormData();
                form.append("file", files[i]);
                const resp = await fetch("/api/upload-cover", { method: "POST", body: form });
                const data = await resp.json();
                if (data.error) {
                    alert(`导入 ${files[i].name} 失败: ${data.error}`);
                    continue;
                }
                lastFilename = data.filename;
            }
            await loadCovers();
            renderCoverGrid();
            if (lastFilename && activeCellIndex >= 0) {
                // 不自动选择，仅刷新列表
            }
        } catch (e) {
            alert("导入出错: " + e.message);
        } finally {
            overlay.remove();
            document.getElementById("uploadCoverInput").value = "";
        }
    }

    // openCoverPicker 打开弹窗并渲染可选封面。
    function openCoverPicker(index) {
        activeCellIndex = index;
        const grid = document.getElementById("coverGrid");
        document.getElementById("modalTitle").textContent = `为「${texts[index]}」选择封面`;

        // 渲染已有封面列表
        renderCoverGrid();

        // 重置搜索状态
        currentTags = [];
        currentPage = 1;
        currentTotal = 0;
        currentSubjectType = "all";
        document.getElementById("searchInput").value = "";
        document.getElementById("resultInfo").style.display = "none";
        document.getElementById("pagination").innerHTML = "";
        document.getElementById("searchResults").innerHTML =
            '<div class="search-status">选择上方题材标签，或直接输入关键词搜索</div>';
        document.querySelectorAll(".type-btn").forEach(b =>
            b.classList.toggle("active", b.dataset.type === "all"));
        _searchVersion += 1;
        _pageCache.clear();
        _inflight.clear();
        syncTagBrowserUI();
        renderTagBadges();

        // 重置 VNDB 搜索状态
        vndbPage = 1;
        vndbTotal = 0;
        _vndbSearchVersion += 1;
        _vndbPageCache.clear();
        _vndbInflight.clear();

        // 重置数据源为 Bangumi
        setSource("bgm");

        // 默认显示已有封面 Tab
        switchTab("covers");
        resetPageSizeCache();
        document.getElementById("coverModal").classList.add("active");
    }

    // selectCover 将选中封面写入当前格子并保存状态。
    function selectCover(url, name) {
        const i = activeCellIndex;
        cellImages[i] = url;
        cellCrops[i] = defaultCrop();
        renderCellImage(i, name);
        closeModal();
        saveState();
    }

    // clearCover 清除当前格子的封面并保存状态。
    function clearCover() {
        const i = activeCellIndex;
        cellImages[i] = null;
        cellCrops[i] = null;
        renderCellImage(i);
        closeModal();
        saveState();
    }

    // closeModal 关闭封面选择弹窗。
    function closeModal() {
        document.getElementById("coverModal").classList.remove("active");
    }

    // 点击弹窗遮罩层关闭
    document.addEventListener("click", (e) => {
        if (e.target === document.getElementById("coverModal")) closeModal();
        if (e.target === document.getElementById("cropModal")) closeCropModal();
    });

    function openCropModal(index) {
        if (!cellImages[index]) return;
        cropEditingIndex = index;
        cropDraft = getCellCrop(index);
        const title = texts[index] || "当前格子";
        document.getElementById("cropTitle").textContent = `裁剪封面 · 「${title}」`;
        const src = cellImages[index];
        const cropImg = document.getElementById("cropImage");
        const previewImg = document.getElementById("cropPreviewImage");
        cropImg.src = src;
        previewImg.src = src;
        [cropImg, previewImg].forEach(el => {
            el.style.width = '100%';
            el.style.height = '100%';
            el.style.objectFit = 'cover';
            el.style.left = '0';
            el.style.top = '0';
        });
        syncCropInputs();
        if (cropImg.complete && cropImg.naturalWidth > 0) {
            applyCropDraftToPreview();
        } else {
            cropImg.onload = () => applyCropDraftToPreview();
        }
        document.getElementById("cropModal").classList.add("active");
    }

    function closeCropModal() {
        document.getElementById("cropModal").classList.remove("active");
        cropEditingIndex = -1;
        cropDraft = null;
        cropDragging = false;
        document.getElementById("cropViewport").classList.remove("dragging");
    }

    function syncCropInputs() {
        if (!cropDraft) return;
        const zoomVal = Math.round(cropDraft.zoom * 100);
        const xVal = Math.round(cropDraft.centerX * 100);
        const yVal = Math.round(cropDraft.centerY * 100);
        document.getElementById("cropZoom").value = String(zoomVal);
        document.getElementById("cropX").value = String(xVal);
        document.getElementById("cropY").value = String(yVal);
        document.getElementById("cropZoomValue").textContent = `${zoomVal}%`;
        document.getElementById("cropXValue").textContent = `${xVal}%`;
        document.getElementById("cropYValue").textContent = `${yVal}%`;
    }

    function applyCropDraftToPreview() {
        if (!cropDraft) return;
        clampCrop(cropDraft);
        const cropImg = document.getElementById("cropImage");
        if (!cropImg.naturalWidth) return;
        const layout = computeCropLayout(
            cropImg.naturalWidth, cropImg.naturalHeight, 3 / 4, cropDraft
        );
        applyCropLayoutToElement(cropImg, layout);
        applyCropLayoutToElement(document.getElementById("cropPreviewImage"), layout);
        syncCropInputs();
    }

    function resetCropDraft() {
        cropDraft = defaultCrop();
        applyCropDraftToPreview();
    }

    function saveCropDraft() {
        if (cropEditingIndex < 0 || !cropDraft) return;
        cellCrops[cropEditingIndex] = clampCrop(cloneCrop(cropDraft));
        renderCellImage(cropEditingIndex);
        saveState();
        closeCropModal();
    }

    document.getElementById("cropZoom").addEventListener("input", (e) => {
        if (!cropDraft) return;
        cropDraft.zoom = Number(e.target.value) / 100;
        cropDraft = clampCrop(cropDraft);
        applyCropDraftToPreview();
    });
    document.getElementById("cropX").addEventListener("input", (e) => {
        if (!cropDraft) return;
        cropDraft.centerX = Number(e.target.value) / 100;
        cropDraft = clampCrop(cropDraft);
        applyCropDraftToPreview();
    });
    document.getElementById("cropY").addEventListener("input", (e) => {
        if (!cropDraft) return;
        cropDraft.centerY = Number(e.target.value) / 100;
        cropDraft = clampCrop(cropDraft);
        applyCropDraftToPreview();
    });

    const cropViewport = document.getElementById("cropViewport");
    cropViewport.addEventListener("pointerdown", (e) => {
        if (!cropDraft) return;
        cropDragging = true;
        cropDragStartX = e.clientX;
        cropDragStartY = e.clientY;
        cropViewport.classList.add("dragging");
        cropViewport.setPointerCapture(e.pointerId);
    });
    cropViewport.addEventListener("pointermove", (e) => {
        if (!cropDragging || !cropDraft) return;
        const dx = e.clientX - cropDragStartX;
        const dy = e.clientY - cropDragStartY;
        cropDragStartX = e.clientX;
        cropDragStartY = e.clientY;

        const cropImg = document.getElementById("cropImage");
        if (!cropImg.naturalWidth) return;
        const rect = cropViewport.getBoundingClientRect();
        const imgRatio = cropImg.naturalWidth / cropImg.naturalHeight;
        const boxRatio = rect.width / rect.height || 3 / 4;
        let wFactor, hFactor;
        if (imgRatio > boxRatio) {
            hFactor = cropDraft.zoom;
            wFactor = cropDraft.zoom * imgRatio / boxRatio;
        } else {
            wFactor = cropDraft.zoom;
            hFactor = cropDraft.zoom * boxRatio / imgRatio;
        }
        const overflowXPx = (wFactor - 1) * rect.width;
        const overflowYPx = (hFactor - 1) * rect.height;
        if (overflowXPx > 0.5) cropDraft.centerX -= dx / overflowXPx;
        if (overflowYPx > 0.5) cropDraft.centerY -= dy / overflowYPx;
        cropDraft = clampCrop(cropDraft);
        applyCropDraftToPreview();
    });
    cropViewport.addEventListener("pointerup", (e) => {
        cropDragging = false;
        cropViewport.classList.remove("dragging");
        if (cropViewport.hasPointerCapture(e.pointerId)) {
            cropViewport.releasePointerCapture(e.pointerId);
        }
    });
    cropViewport.addEventListener("pointercancel", () => {
        cropDragging = false;
        cropViewport.classList.remove("dragging");
    });

    // switchTab 切换弹窗内的 tab 面板。
    function switchTab(tab) {
        document.querySelectorAll(".modal-tab").forEach(t =>
            t.classList.toggle("active", t.dataset.tab === tab));
        document.getElementById("tabCovers").classList.toggle("active", tab === "covers");
        document.getElementById("tabSearch").classList.toggle("active", tab === "search");
        if (tab === "search") {
            setTimeout(() => document.getElementById("searchInput").focus(), 100);
        }
    }

    // setSource 切换搜索数据源，显示/隐藏对应控件。
    function setSource(src) {
        currentSource = src;
        document.querySelectorAll(".source-btn").forEach(b =>
            b.classList.toggle("active", b.dataset.source === src));
        document.getElementById("bgmControls").style.display = src === "bgm" ? "" : "none";
        document.getElementById("vndbGuide").style.display = src === "vndb" ? "flex" : "none";
        const input = document.getElementById("searchInput");
        const barLabel = document.getElementById("searchBarLabel");
        if (src === "vndb") {
            input.placeholder = "输入 Galgame / 视觉小说名称搜索...";
            barLabel.innerHTML = '关键词 <span class="section-hint">— 输入作品中/日/英名称</span>';
        } else {
            input.placeholder = "输入关键词进一步筛选（可选）...";
            barLabel.innerHTML = '关键词 <span class="section-hint">— 输入作品名称进一步筛选</span>';
        }
        // 切换数据源时重置搜索按钮状态并清空结果
        const btn = document.getElementById("searchBtn");
        btn.disabled = false;
        btn.textContent = "搜索";
        resetSearchResults();
    }

    // ---- 搜索面板功能 ----

    // initTagBrowser 按分类渲染标签选择按钮。
    function initTagBrowser() {
        const browser = document.getElementById("tagBrowser");
        browser.innerHTML = "";
        allTags.forEach(({ label, tags }) => {
            const row = document.createElement("div");
            row.className = "tag-cat-row";
            row.innerHTML = `<span class="tag-cat-label">${label}</span>`;
            const group = document.createElement("div");
            group.className = "tag-cat-group";
            tags.forEach(tag => {
                const btn = document.createElement("button");
                btn.className = "tag-pick-btn";
                btn.textContent = tag;
                btn.dataset.tag = tag;
                btn.onclick = () => toggleTag(tag);
                group.appendChild(btn);
            });
            row.appendChild(group);
            browser.appendChild(row);
        });
    }

    // syncTagBrowserUI 同步标签按钮的选中高亮。
    function syncTagBrowserUI() {
        document.querySelectorAll(".tag-pick-btn").forEach(btn =>
            btn.classList.toggle("active", currentTags.includes(btn.dataset.tag)));
    }

    // renderTagBadges 渲染已选标签徽章。
    function renderTagBadges() {
        const container = document.getElementById("tagBadges");
        container.innerHTML = "";
        currentTags.forEach((tag, idx) => {
            const badge = document.createElement("span");
            badge.className = "tag-badge";
            badge.innerHTML = `${tag} <span class="remove-tag" onclick="removeTag(${idx})">×</span>`;
            container.appendChild(badge);
        });
    }

    // toggleTag 切换标签选中状态，有条件时自动搜索。
    function toggleTag(tag) {
        const idx = currentTags.indexOf(tag);
        if (idx === -1) currentTags.push(tag);
        else currentTags.splice(idx, 1);
        syncTagBrowserUI();
        renderTagBadges();
        if (hasSearchCondition()) doSearch();
        else resetSearchResults();
    }

    // removeTag 移除指定位置的标签。
    function removeTag(idx) {
        currentTags.splice(idx, 1);
        syncTagBrowserUI();
        renderTagBadges();
        if (hasSearchCondition()) doSearch();
        else resetSearchResults();
    }

    // setSubjectType 切换作品类型筛选。
    function setSubjectType(type) {
        currentSubjectType = type;
        document.querySelectorAll(".type-btn").forEach(b =>
            b.classList.toggle("active", b.dataset.type === type));
        if (hasSearchCondition()) doSearch();
    }

    // onSortChange 排序字段变更时触发搜索。
    function onSortChange() {
        if (hasSearchCondition()) doSearch();
    }

    // hasSearchCondition 判断是否有有效搜索条件。
    function hasSearchCondition() {
        if (currentSource === "vndb") {
            return !!document.getElementById("searchInput").value.trim();
        }
        return currentTags.length > 0
            || document.getElementById("searchInput").value.trim()
            || currentSubjectType !== "all";
    }

    // resetSearchResults 清空搜索结果区。
    function resetSearchResults() {
        let icon, hint;
        if (currentSource === "vndb") {
            icon = "🎮";
            hint = "输入视觉小说名称开始搜索<br><span style='font-size:11px;color:#bbb'>支持中文、日文原名、英文名，模糊匹配</span>";
        } else {
            icon = "🔍";
            hint = "选择上方题材标签，或直接输入关键词搜索<br><span style='font-size:11px;color:#bbb'>可组合多个标签 + 关键词 + 类型筛选</span>";
        }
        document.getElementById("searchResults").innerHTML =
            `<div class="search-status"><span class="search-status-icon">${icon}</span>${hint}</div>`;
        document.getElementById("resultInfo").style.display = "none";
        document.getElementById("pagination").innerHTML = "";
    }

    // doSearch 触发搜索（300ms 防抖），根据当前数据源分发。
    function doSearch() {
        if (currentSource === "vndb") {
            doVNDBSearch();
            return;
        }
        currentPage = 1;
        _searchVersion += 1;
        _pageCache.clear();
        _inflight.clear();
        clearTimeout(_searchTimer);
        _searchTimer = setTimeout(() => loadAndRenderPage(currentPage, true), 300);
    }

    // currentSearchParams 读取当前搜索参数快照，避免请求过程被 UI 改动影响。
    function currentSearchParams() {
        return {
            sort: document.getElementById("sortSelect").value,
            keyword: document.getElementById("searchInput").value.trim(),
            subjectType: currentSubjectType,
            tags: [...currentTags],
        };
    }

    // pageCacheKey 生成分页缓存键，绑定搜索条件和页码。
    function pageCacheKey(params, page) {
        return JSON.stringify([
            params.tags,
            params.keyword,
            params.subjectType,
            params.sort,
            page,
            getSearchPageSize(),
        ]);
    }

    // trimCache 如果缓存超限，删除最早写入的条目。
    function trimCache() {
        while (_pageCache.size > CACHE_LIMIT) {
            const oldestKey = _pageCache.keys().next().value;
            if (!oldestKey) break;
            _pageCache.delete(oldestKey);
        }
    }

    // fetchPageData 获取指定页数据：先读缓存，再复用飞行中请求，最后发新请求。
    async function fetchPageData(page, params, version) {
        const key = pageCacheKey(params, page);
        if (_pageCache.has(key)) {
            return _pageCache.get(key);
        }
        if (_inflight.has(key)) {
            return _inflight.get(key);
        }

        const pageSize = getSearchPageSize();
        const offset = (page - 1) * pageSize;
        const body = {
            offset,
            limit: pageSize,
            sort: params.sort,
            subjectType: params.subjectType,
        };
        if (params.tags.length > 0) body.tags = params.tags;
        if (params.keyword) body.keyword = params.keyword;

        // 漫画/小说使用游标式分页：从上一页响应中取 next_api_offset
        if (page > 1 && (params.subjectType === "manga" || params.subjectType === "novel")) {
            const prevKey = pageCacheKey(params, page - 1);
            const prevData = _pageCache.get(prevKey);
            if (prevData && prevData.next_api_offset) {
                body.apiOffset = prevData.next_api_offset;
            }
        }

        const promise = (async () => {
            const resp = await fetch("/api/browse", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body)
            });
            const data = await resp.json();
            if (!data.error && version === _searchVersion) {
                _pageCache.set(key, data);
                trimCache();
            }
            return data;
        })();

        _inflight.set(key, promise);
        promise.finally(() => _inflight.delete(key));
        return promise;
    }

    // prefetchAround 后台预加载相邻页，复用 fetchPageData 去重逻辑。
    // 漫画/小说使用游标分页，必须串行预加载（下一页依赖上一页的响应）。
    function prefetchAround(page, totalPages, params, version) {
        const isSubFiltered = params.subjectType === "manga" || params.subjectType === "novel";
        if (isSubFiltered) {
            // 只预加载下一页，且等当前页缓存就绪后串行执行
            const nextPage = page + 1;
            if (nextPage <= totalPages) {
                const curKey = pageCacheKey(params, page);
                // 当前页已缓存时直接预加载；否则等缓存写入后预加载
                if (_pageCache.has(curKey)) {
                    fetchPageData(nextPage, params, version).catch(() => {});
                }
                // 如果当前页还在飞行中，loadAndRenderPage 完成后会再调 prefetchAround
            }
            return;
        }
        PREFETCH_STEPS.forEach(step => {
            const nextPage = page + step;
            if (nextPage < 1 || nextPage > totalPages || nextPage === page) {
                return;
            }
            fetchPageData(nextPage, params, version).catch(() => {});
        });
    }

    // loadAndRenderPage 加载并渲染指定页，支持缓存命中、请求去重和后台预加载。
    async function loadAndRenderPage(page, showLoading) {
        const version = _searchVersion;
        const params = currentSearchParams();

        const resultsDiv = document.getElementById("searchResults");
        const btn = document.getElementById("searchBtn");
        _loadingRequests += 1;
        btn.disabled = true;
        btn.textContent = "搜索中...";
        if (showLoading) {
            resultsDiv.innerHTML = '<div class="search-status"><div class="spinner"></div><br>正在加载作品...</div>';
            document.getElementById("pagination").innerHTML = "";
        }

        try {
            const data = await fetchPageData(page, params, version);
            if (version !== _searchVersion) return;
            if (page !== currentPage) return;

            if (data.error) {
                resultsDiv.innerHTML = `<div class="search-status">❌ ${data.error}</div>`;
                return;
            }
            renderBrowseResults(data);
            const totalPages = Math.max(1, Math.ceil((data.total || 0) / getSearchPageSize()));
            prefetchAround(page, totalPages, params, version);
        } catch (e) {
            if (version !== _searchVersion) return;
            if (page !== currentPage) return;
            resultsDiv.innerHTML = `<div class="search-status">❌ 搜索出错: ${e.message}</div>`;
        } finally {
            _loadingRequests = Math.max(0, _loadingRequests - 1);
            if (_loadingRequests === 0) {
                btn.disabled = false;
                btn.textContent = "搜索";
            }
        }
    }

    // renderBrowseResults 渲染搜索结果卡片和分页。
    function renderBrowseResults(data) {
        const resultsDiv = document.getElementById("searchResults");
        currentTotal = data.total || 0;
        const items = data.results || [];
        const totalPages = Math.max(1, Math.ceil(currentTotal / getSearchPageSize()));

        // 显示结果信息
        const infoDiv = document.getElementById("resultInfo");
        infoDiv.style.display = "flex";
        document.getElementById("resultCount").textContent =
            `共 ${currentTotal} 个结果 · 第 ${currentPage} / ${totalPages} 页`;

        if (items.length === 0) {
            resultsDiv.innerHTML = '<div class="search-status">没有找到相关作品</div>';
            document.getElementById("pagination").innerHTML = "";
            return;
        }

        // 渲染结果卡片
        resultsDiv.innerHTML = "";
        const grid = document.createElement("div");
        grid.className = "search-results";
        resultsDiv.appendChild(grid);

        items.forEach(item => {
            const el = document.createElement("div");
            el.className = "search-item";
            const displayName = item.name_cn || item.name;
            const subName = item.name_cn ? item.name : "";
            const coverSrc = item.cover || "";
            const typeLabel = item.type_label || "";
            const typeClass = typeLabel === "动画" ? "type-anime"
                            : typeLabel === "游戏" ? "type-game"
                            : typeLabel === "漫画" ? "type-manga"
                            : typeLabel === "小说" ? "type-novel" : "";
            const score = item.score ? `⭐${item.score}` : "";

            el.innerHTML = `
                ${coverSrc
                    ? `<img class="search-item-img" src="${coverSrc}" alt="${displayName}" loading="lazy"
                           onerror="this.style.display='none'">`
                    : `<div class="search-item-img" style="display:flex;align-items:center;justify-content:center;color:#ccc;font-size:24px;">无图</div>`
                }
                <div class="search-item-info">
                    <div class="search-item-name" title="${displayName}">${displayName}</div>
                    ${subName ? `<div class="search-item-sub" title="${subName}">${subName}</div>` : ""}
                </div>
                <div class="search-item-meta">
                    <span class="source-badge source-bgm">BGM</span>
                    ${typeLabel ? `<span class="search-item-type ${typeClass}">${typeLabel}</span>` : ""}
                    ${score ? `<span class="search-item-score">${score}</span>` : ""}
                </div>
            `;
            el.onclick = () => downloadAndApplyCover(item, "bgm");
            grid.appendChild(el);
        });

        renderPagination(totalPages);
    }

    // renderPagination 渲染分页按钮。
    function renderPagination(totalPages) {
        const pag = document.getElementById("pagination");
        pag.innerHTML = "";
        if (totalPages <= 1) return;

        const addBtn = (label, page, disabled = false, active = false) => {
            const b = document.createElement("button");
            b.className = "page-btn" + (active ? " active" : "");
            b.textContent = label;
            b.disabled = disabled;
            if (!disabled && !active) b.onclick = () => goToPage(page);
            pag.appendChild(b);
        };
        const addEllipsis = () => {
            const s = document.createElement("span");
            s.className = "page-ellipsis";
            s.textContent = "…";
            pag.appendChild(s);
        };

        // 上一页
        addBtn("‹", currentPage - 1, currentPage <= 1);
        // 页码（当前页前后各显示 2 页，首尾超范围加省略号）
        const WING = 2;
        let lo = Math.max(1, currentPage - WING);
        let hi = Math.min(totalPages, currentPage + WING);
        if (lo > 1) { addBtn("1", 1); if (lo > 2) addEllipsis(); }
        for (let p = lo; p <= hi; p++) addBtn(String(p), p, false, p === currentPage);
        if (hi < totalPages) { if (hi < totalPages - 1) addEllipsis(); addBtn(String(totalPages), totalPages); }
        // 下一页
        addBtn("›", currentPage + 1, currentPage >= totalPages);
    }

    // goToPage 跳转到指定页。
    // 漫画/小说使用游标分页，跳页时需要按顺序拉取中间页以构建游标链。
    async function goToPage(page) {
        currentPage = page;
        const params = currentSearchParams();
        const key = pageCacheKey(params, page);
        const shouldShowLoading = !_pageCache.has(key) && !_inflight.has(key);

        // 漫画/小说：确保前序页的游标链完整
        if (page > 1 && (params.subjectType === "manga" || params.subjectType === "novel")) {
            const prevKey = pageCacheKey(params, page - 1);
            if (!_pageCache.has(prevKey) && !_inflight.has(prevKey)) {
                const ver = _searchVersion;
                if (shouldShowLoading) {
                    document.getElementById("searchResults").innerHTML =
                        '<div class="search-status"><div class="spinner"></div><br>正在加载作品...</div>';
                }
                for (let p = 1; p < page; p++) {
                    const pk = pageCacheKey(params, p);
                    if (!_pageCache.has(pk)) {
                        await fetchPageData(p, params, ver);
                    }
                    if (ver !== _searchVersion) return; // 搜索条件已变，放弃
                }
            }
        }

        loadAndRenderPage(page, shouldShowLoading);
        document.getElementById("searchResults").scrollIntoView({ behavior: "smooth", block: "start" });
    }

    // downloadAndApplyCover 下载搜索结果的封面并应用到当前格子。
    // source: "bgm" 或 "vndb"，决定后端使用哪个客户端下载。
    async function downloadAndApplyCover(item, source) {
        if (!item.cover) {
            alert("该作品没有封面图片");
            return;
        }

        // 显示下载遮罩
        const overlay = document.createElement("div");
        overlay.className = "download-overlay";
        overlay.innerHTML = `<div class="download-overlay-box">
            <div class="spinner"></div>
            <div>正在下载封面...</div>
        </div>`;
        document.body.appendChild(overlay);

        try {
            const displayName = item.name_cn || item.name || "cover";
            const safeName = displayName.replace(/[<>:"\/\\|?*\s]/g, "_").substring(0, 60);
            const filename = `${safeName}_${item.id}`;

            const resp = await fetch("/api/download-cover", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url: item.cover, filename, source: source || "bgm" })
            });
            const data = await resp.json();

            if (data.error) {
                alert("下载失败: " + data.error);
                return;
            }

            // 将下载的封面应用到当前格子
            const coverPath = "covers/" + encodeURIComponent(data.filename);
            selectCover(coverPath, data.filename);
            await loadCovers();
        } catch (e) {
            alert("下载出错: " + e.message);
        } finally {
            overlay.remove();
        }
    }

    // ---- VNDB 搜索功能 ----

    // doVNDBSearch 触发 VNDB 搜索（300ms 防抖）。
    function doVNDBSearch() {
        const keyword = document.getElementById("searchInput").value.trim();
        if (!keyword) return;
        vndbPage = 1;
        _vndbSearchVersion += 1;
        _vndbPageCache.clear();
        _vndbInflight.clear();
        clearTimeout(_vndbSearchTimer);
        _vndbSearchTimer = setTimeout(() => loadAndRenderVNDBPage(vndbPage, true), 300);
    }

    // vndbPageCacheKey 生成 VNDB 分页缓存键。
    function vndbPageCacheKey(keyword, page) {
        return JSON.stringify(["vndb", keyword, page, getSearchPageSize()]);
    }

    // fetchVNDBPageData 获取 VNDB 指定页数据，带缓存和去重。
    async function fetchVNDBPageData(page, keyword, version) {
        const key = vndbPageCacheKey(keyword, page);
        if (_vndbPageCache.has(key)) return _vndbPageCache.get(key);
        if (_vndbInflight.has(key)) return _vndbInflight.get(key);

        const promise = (async () => {
            const resp = await fetch("/api/vndb/search", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ keyword, page, limit: getSearchPageSize() })
            });
            const data = await resp.json();
            if (!data.error && version === _vndbSearchVersion) {
                _vndbPageCache.set(key, data);
                while (_vndbPageCache.size > CACHE_LIMIT) {
                    _vndbPageCache.delete(_vndbPageCache.keys().next().value);
                }
            }
            return data;
        })();

        _vndbInflight.set(key, promise);
        promise.finally(() => _vndbInflight.delete(key));
        return promise;
    }

    // prefetchVNDBAround 后台预加载 VNDB 相邻页。
    function prefetchVNDBAround(page, totalPages, keyword, version) {
        VNDB_PREFETCH_STEPS.forEach(step => {
            const p = page + step;
            if (p >= 1 && p <= totalPages && p !== page)
                fetchVNDBPageData(p, keyword, version).catch(() => {});
        });
    }

    // loadAndRenderVNDBPage 加载并渲染 VNDB 指定页（使用共享结果区域）。
    async function loadAndRenderVNDBPage(page, showLoading) {
        const version = _vndbSearchVersion;
        const keyword = document.getElementById("searchInput").value.trim();
        if (!keyword) return;

        const resultsDiv = document.getElementById("searchResults");
        const btn = document.getElementById("searchBtn");
        _vndbLoadingRequests += 1;
        btn.disabled = true;
        btn.textContent = "搜索中...";
        if (showLoading) {
            resultsDiv.innerHTML = '<div class="search-status"><div class="spinner"></div><br>正在搜索 VNDB...</div>';
            document.getElementById("pagination").innerHTML = "";
        }

        try {
            const data = await fetchVNDBPageData(page, keyword, version);
            if (version !== _vndbSearchVersion) return;
            if (page !== vndbPage) return;

            if (data.error) {
                resultsDiv.innerHTML = `<div class="search-status">❌ ${data.error}</div>`;
                return;
            }
            renderVNDBResults(data);
            const totalPages = Math.max(1, Math.ceil((data.total || 0) / getSearchPageSize()));
            prefetchVNDBAround(page, totalPages, keyword, version);
        } catch (e) {
            if (version !== _vndbSearchVersion) return;
            if (page !== vndbPage) return;
            resultsDiv.innerHTML = `<div class="search-status">❌ 搜索出错: ${e.message}</div>`;
        } finally {
            _vndbLoadingRequests = Math.max(0, _vndbLoadingRequests - 1);
            if (_vndbLoadingRequests === 0) {
                btn.disabled = false;
                btn.textContent = "搜索";
            }
        }
    }

    // renderVNDBResults 渲染 VNDB 搜索结果卡片和分页。
    function renderVNDBResults(data) {
        const resultsDiv = document.getElementById("searchResults");
        vndbTotal = data.total || 0;
        const items = data.results || [];
        const totalPages = Math.max(1, Math.ceil(vndbTotal / getSearchPageSize()));

        const infoDiv = document.getElementById("resultInfo");
        infoDiv.style.display = "flex";
        document.getElementById("resultCount").textContent =
            `共 ${vndbTotal} 个结果 · 第 ${vndbPage} / ${totalPages} 页`;

        if (items.length === 0) {
            resultsDiv.innerHTML = '<div class="search-status">没有找到相关作品</div>';
            document.getElementById("pagination").innerHTML = "";
            return;
        }

        resultsDiv.innerHTML = "";
        const grid = document.createElement("div");
        grid.className = "search-results";
        resultsDiv.appendChild(grid);

        items.forEach(item => {
            const el = document.createElement("div");
            el.className = "search-item";
            const displayName = item.name_cn || item.name;
            const subName = item.name_cn ? item.name : "";
            const coverSrc = item.cover || "";
            const score = item.score ? `⭐${item.score.toFixed(1)}` : "";

            el.innerHTML = `
                ${coverSrc
                    ? `<img class="search-item-img" src="${coverSrc}" alt="${displayName}" loading="lazy"
                           onerror="this.style.display='none'">`
                    : `<div class="search-item-img" style="display:flex;align-items:center;justify-content:center;color:#ccc;font-size:24px;">无图</div>`
                }
                <div class="search-item-info">
                    <div class="search-item-name" title="${displayName}">${displayName}</div>
                    ${subName ? `<div class="search-item-sub" title="${subName}">${subName}</div>` : ""}
                </div>
                <div class="search-item-meta">
                    <span class="source-badge source-vndb">VNDB</span>
                    ${score ? `<span class="search-item-score">${score}</span>` : ""}
                </div>
            `;
            el.onclick = () => downloadAndApplyCover(item, "vndb");
            grid.appendChild(el);
        });

        renderVNDBPagination(totalPages);
    }

    // renderVNDBPagination 渲染 VNDB 分页按钮。
    function renderVNDBPagination(totalPages) {
        const pag = document.getElementById("pagination");
        pag.innerHTML = "";
        if (totalPages <= 1) return;

        const addBtn = (label, page, disabled = false, active = false) => {
            const b = document.createElement("button");
            b.className = "page-btn" + (active ? " active" : "");
            b.textContent = label;
            b.disabled = disabled;
            if (!disabled && !active) b.onclick = () => goToVNDBPage(page);
            pag.appendChild(b);
        };
        const addEllipsis = () => {
            const s = document.createElement("span");
            s.className = "page-ellipsis";
            s.textContent = "…";
            pag.appendChild(s);
        };

        addBtn("‹", vndbPage - 1, vndbPage <= 1);
        const WING = 2;
        let lo = Math.max(1, vndbPage - WING);
        let hi = Math.min(totalPages, vndbPage + WING);
        if (lo > 1) { addBtn("1", 1); if (lo > 2) addEllipsis(); }
        for (let p = lo; p <= hi; p++) addBtn(String(p), p, false, p === vndbPage);
        if (hi < totalPages) { if (hi < totalPages - 1) addEllipsis(); addBtn(String(totalPages), totalPages); }
        addBtn("›", vndbPage + 1, vndbPage >= totalPages);
    }

    // goToVNDBPage 跳转 VNDB 指定页。
    function goToVNDBPage(page) {
        vndbPage = page;
        const keyword = document.getElementById("searchInput").value.trim();
        const key = vndbPageCacheKey(keyword, page);
        const shouldShowLoading = !_vndbPageCache.has(key) && !_vndbInflight.has(key);
        loadAndRenderVNDBPage(page, shouldShowLoading);
        document.getElementById("searchResults").scrollIntoView({ behavior: "smooth", block: "start" });
    }

    // saveState 将格子数据保存到服务端 state.json。
    async function saveState() {
        try {
            await fetch("/api/state", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ cells: cellImages, crops: cellCrops })
            });
        } catch (e) {
            console.warn("保存状态失败:", e);
        }
    }

    // loadState 从服务端读取并恢复已保存的格子状态。
    async function loadState() {
        try {
            const resp = await fetch("/api/state");
            if (!resp.ok) return;
            const data = await resp.json();
            if (!data.cells) return;
            data.cells.forEach((url, i) => {
                if (url && i < cellImages.length) {
                    cellImages[i] = url;
                    if (Array.isArray(data.crops) && data.crops[i]) {
                        cellCrops[i] = clampCrop(cloneCrop(data.crops[i]));
                    } else {
                        cellCrops[i] = defaultCrop();
                    }
                    renderCellImage(i);
                }
            });
        } catch (e) {
            console.warn("加载状态失败:", e);
        }
    }

    // saveImage 将当前表格绘制到 canvas 并下载为 PNG。
    async function saveImage() {
        const cols = 6;
        const rows = 10;
        const boxW = 220;
        const boxH = 310;
        const border = 2;
        const padding = 36;
        const titleH = 70;
        const labelH = 40;
        const totalW = padding * 2 + cols * boxW + (cols + 1) * border;
        const totalH = padding * 2 + titleH + rows * boxH + (rows + 1) * border;

        const canvas = document.getElementById("exportCanvas");
        const ctx = canvas.getContext("2d");
        canvas.width = totalW;
        canvas.height = totalH;
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";

        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, totalW, totalH);

        ctx.fillStyle = "#333";
        ctx.font = "bold 36px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("ACGN生涯个人喜好表", totalW / 2, padding + titleH / 2);

        const loadImg = (src) => new Promise((resolve) => {
            if (!src) {
                resolve(null);
                return;
            }
            if (_imgCache.has(src)) {
                resolve(_imgCache.get(src));
                return;
            }
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                _imgCache.set(src, img);
                resolve(img);
            };
            img.onerror = () => resolve(null);
            img.src = src;
        });

        const imgs = await Promise.all(cellImages.map(loadImg));
        const gridLeft = padding;
        const gridTop = padding + titleH;

        for (let i = 0; i < texts.length; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            const x = gridLeft + col * boxW + (col + 1) * border;
            const y = gridTop + row * boxH + (row + 1) * border;

            ctx.fillStyle = "#fff";
            ctx.fillRect(x, y, boxW, boxH);

            if (imgs[i]) {
                ctx.save();
                ctx.beginPath();
                ctx.rect(x, y, boxW, boxH - labelH);
                ctx.clip();
                coverDraw(ctx, imgs[i], x, y, boxW, boxH - labelH, getCellCrop(i));
                ctx.restore();
            }

            const textY = y + boxH - labelH;
            ctx.fillStyle = "#f0f0f0";
            ctx.fillRect(x, textY, boxW, labelH);
            ctx.strokeStyle = "#ccc";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, textY);
            ctx.lineTo(x + boxW, textY);
            ctx.stroke();

            ctx.fillStyle = "#333";
            ctx.font = "bold 18px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(texts[i], x + boxW / 2, textY + labelH / 2);
        }

        ctx.strokeStyle = "#333";
        ctx.lineWidth = border;
        const gridW = cols * boxW + (cols + 1) * border;
        const gridH = rows * boxH + (rows + 1) * border;

        for (let r = 0; r <= rows; r++) {
            const lineY = gridTop + r * boxH + r * border + border / 2;
            ctx.beginPath();
            ctx.moveTo(gridLeft, lineY);
            ctx.lineTo(gridLeft + gridW, lineY);
            ctx.stroke();
        }

        for (let c = 0; c <= cols; c++) {
            const lineX = gridLeft + c * boxW + c * border + border / 2;
            ctx.beginPath();
            ctx.moveTo(lineX, gridTop);
            ctx.lineTo(lineX, gridTop + gridH);
            ctx.stroke();
        }

        const link = document.createElement("a");
        link.download = "ACGN生涯个人喜好表.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
    }

    // coverDraw 使用 cover 方式绘制图片并应用裁剪（centerX/centerY 控制全图内的可视区域偏移）。
    function coverDraw(ctx, img, x, y, w, h, crop = defaultCrop()) {
        crop = clampCrop(cloneCrop(crop));
        const imageRatio = img.width / img.height;
        const boxRatio = w / h;
        let baseW, baseH;
        if (imageRatio > boxRatio) {
            baseH = img.height;
            baseW = baseH * boxRatio;
        } else {
            baseW = img.width;
            baseH = baseW / boxRatio;
        }

        const srcW = baseW / crop.zoom;
        const srcH = baseH / crop.zoom;
        const maxOffX = img.width - srcW;
        const maxOffY = img.height - srcH;
        const srcX = crop.centerX * maxOffX;
        const srcY = crop.centerY * maxOffY;

        ctx.drawImage(img, srcX, srcY, srcW, srcH, x, y, w, h);
    }

    // 启动流程：初始化网格、标签浏览器，再加载封面和状态。
    initGrid();
    initTagBrowser();
    loadCovers();
    loadState();
</script>

</body>
</html>
